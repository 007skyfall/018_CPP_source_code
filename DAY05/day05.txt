回顾：
	1. 拷贝赋值
	
	定义，两个实例化的对象，进行赋值操作，
	调用拷贝赋值函数。
	
	类名&  operator=(const A& that)
	{
		if(this != &that){
		
		}
		return *this;
	}
	
	浅拷贝和深拷贝的问题
	
2. this指针和常函数
	class A{
	public:
	
		void  foo(void){
		cout << m_data << endl}
		void foo(A *this){
		cout << this->m_data <<endl;
		}
		
	private:
		int m_data;
	}
	
	显示使用this的情况：
	1》构造函数的形参名和成员变量的名字一致；
	2》返回自引用
	3》在类的内部销毁堆区的对象时，必须显示的使用
	
3. 常函数
	返回类型   函数名(形参表) const{}
	
	cosnt用于修饰this指针
	
	class A{
		public:
		void foo(void)const{}
		void foo(const A *this){}
	};

4. 静态成员
	使用static进行修饰
	
	1. 静态成员变量
	静态成员变量不属于类，
	静态成员必须在类的外部完成初始化，
	不能使用初始化表
	静态成员受访问控制属性的限制
	
	
	2. 静态成员函数
	静态成员函数没有this指针，
	只能访问静态成员变量，不能访问普通成员变量。
	
	普通的成员函数，既可以访问静态成员变量，
	也可以访问普通成员变量。
	
5. 运算符的重载
	+ 运算符重新实现，可以做复数的加法
	
	返回类型  operator+(A& that){
		
	}
####################################################
【1】继承
1.	定义：继承是一种机制，
	使用已有的数据类型去定义新的数据类型，
	这种方式叫做继承。
	
eg：
	人  类：姓名  年龄  吃喝拉撒睡
	学生类：姓名  年龄  吃喝拉撒睡  学习
	老师类：姓名  年龄  吃喝拉撒睡  授课  工资
		这种方式造成代码冗余
		
可以使用继承的方式，继承人类中的属性和行为，
	这样代码会更加的简洁
	人  类：        姓名  年龄  吃喝拉撒睡
	学生类继承人类：学习
	老师类继承人类：授课  工资
	
	人     类   ---》基类/父类
	/       \
  学生类  教师类   ----》派生类/子类
  
2. 继承语法
	
	class 子类的类名:继承的方式  基类的类名{};
	
	继承的方式：
	public：公有的继承  ---》最常用
	private：私有继承
	protected：保护继承
	
	参考案例：01inter.cpp
	
3. 公有继承的特性
	子类对象会继承基类对象的属性和行为，通过子类对象可以
	访问基类中的属性和行为，就相当于是自己的一样。
	
	子类中访问基类中，保护的和公有的成员，如同访问自己的
	是一样的，但是基类中私有的成员，在子类中是存在但是不可见，
	基类中可以提供公有的接口函数，子类间接访问基类中的私有成员。
	
	如果在子类中直接访问基类中的私有成员编译器会报错。
	
4. 类型转换
	1》向上造型  ----》使用最多
	eg：
	Student stu("孙悟空",1000, 1, 100001);
	
	Human *man = &stu;  编译是可以通过，
	
	缩小访问范围的类型转换，叫做向上造型，
	完成隐士类型的转换。

	2》向下造型
	eg：
	
	Student *stu1 = man;
	
	放大访问范围的类型转换，叫做向上造型，
	但是这是不安全的，编译会报错，必须使用强制类型转换
	
	
	Human women("白骨精", 500, 38);
	Teacher *tea1 = (Teacher*)(&women);  // 结果不可预知
	
5. 基类中的构造函数和析构函数，子类是无法继承的，
	但是可以通过初始化表的方式，显示的使用基类中的
	构造函数，完成对基类中的成员的初始化。
	
	语法：
	class 子类类名:public 基类{
		子类类名(子类的形参表):基类构造函数名(实参),
			子类中其他成员的初始化,...{}
	}
	参考案例：02inter.cpp
6.子类中隐藏基类中的成员
	eg:
	class A {
		public:
		void foo(void){}
		void foo(int i){}
	};
	
	class B:public A{
		public:
		void foo(void){}
	}
	
	子类和基类中定义相同的成员函数，作用域是不同的，
	如果函数名相同，类型不同，他们不可以构成重载的关系,
	基类中会隐藏子类的成员函数，如果需要显示的去使用
	子类中的隐藏成员函数，需要使用“类名::成员函数”作用域 
	限定符显示的调用。
	
	如果同名的函数，不同的参数，可以使用using声明的方式，
	将基类中的成员函数引入子类中，让其与子类中的函数构成
	重载关系。
	
	参考案例：03inter.cpp
	
7.继承方式和访问控制属性
	类中成员属性   类内     子类      外部
		public		OK  	  OK		OK 
		protected   OK		  OK 		NO
		private 	OK		  NO		NO 
		
	查看图：继承访问控制属性变化.png
	
	参考案例：04inter.cpp

8. 子类中的构造函数
	1》如果子类中的构造函数没有显示的指明基类中的
		构造函数的初始化方式，编译器默认执行的缺省
		无惨构造函数。
		
	2》如果希望基类中的有参构造函数被子类中显示的方式
		进行调用的，必须通过初始化表的方式，进行显示的调用。
		
		参考案例：05inter.cpp 
		
		构造函数调用的顺序：
		基类中的构造函数 
		子类中的构造函数

9. 子类中的析构函数
	1》子类中的析构函数，无论是自己定义的换是缺省提供的，
		都会调用基类中析构函数，完成基类析构。
		
		析构函数调用的循序：   谁后声明先析构谁
		1.子类析构函数
		2. 基类中的析构函数
	
		参考案例：06inter.cpp 
		
10. 多重继承
	
	父母     岳父岳母
	  \       /
	   \     /
	    夫妻
	
	
	功能机    MP3/MP4   计算机
		\        |      /  
		 \       |     /
		  \      |    /
		 	 智能手机
			 
	1》定义：
	一个子类中同时继承多个基类，这样的继承方式就是多重继承。
	
	测试代码：07inter.cpp 
	
	
	2》将继承自多个基类的子类类型的指针，隐士的转换为基类类型
	（向上造型），编译器会根据每个基类子对象的内存布局，
	进行适当的偏移计算，保证指针的类型和其所指向的目标的类型一致。
	
	
【2】多态	
	函数的多种表示形态。

	参考代码：08ploy.cpp 	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	