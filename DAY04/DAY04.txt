回顾：

1. 初始化表
	类名(形参):(初始化表)成员变量(形参名),...{
	
	}

	1. 使用const关键字修饰的成员
		引用类型的成员
	2. 类中包含类 类型的成员变量

2. 析构函数
	构造函数中申请的空间，需要在析构函数中释放
	
	~类名(void){}
	
	1. 析构函数只有一个，不可以重载
	2. 缺省的析构函数，什么都不干
	3. 析构函数的调用时机
		栈区：遇到左右域的“}”调用析构函数
		堆区：执行delete时，调用析构函数
	4. 如果类中包含了类类型的成员，调用成员子对象的
		析构函数。
		
		clsss A{
		
		};
		class B{
			A a;    // 成员子对象
		};
		B *b = new B;
		delete b;
		b = NULL;
		析构函数在调用时，从外到里去析构
	

3. 拷贝构造函数

	A a1(a);
	A a1 = a;
	类名(const 类名& that){
		对类中的成员变量，一对一的进行拷贝
	}
	1. 如果显示的定义了一个拷贝构造函数，
		编译器不在提供缺省的拷贝构造函数
	2. 缺省的拷贝构造函数，是一个浅拷贝
	3. 如果成员变量中有指针类型的，显示的完成深拷贝，
	4. 如果类中有类 类型的成员变量，调用对应类中拷贝构造函数。

############################################################
【1】拷贝赋值函数
	eg：
	
	class A{
	public:
		A(int data):m_data(data){}
	private:
		int m_data;
	}
	
	A a1(100);
	A a2(200);
	
	a1 = a2;  // 编译器将其编译成  拷贝赋值
	a1.operator=(a2);  // 实际调用拷贝赋值函数
	
	语法格式：
	
	类名&  operator=(const 类名& that)
	{
		if(this != &that)  //防止自赋值
		{
		
		}
		return *this;  // 返回自引用
	}
	
	定义：两个已经实例化的对象，进行赋值的操作，
		此时会调用拷贝赋值函数
	
	案例：01copyassign.cpp

2. 缺省的拷贝赋值函数	
	1》如果类中没有写拷贝赋值函数，编译器默认会提供一个缺省的拷贝赋值函数
			缺省的拷贝赋值函数是一个浅拷贝
	2》拷贝赋值函数是对类中的成员一对一进行拷贝赋值的。
	3》如果类中已经包含了一个拷贝赋值函数，编译器不在提供缺省的拷贝赋值函数
	4》对于类中包含类 类型的成员变量，会调用对应类中的拷贝赋值函数
	5》如果类中包含指针类型的变量是，需要自己实现深拷贝。
	
	参考案例：02copyassign.cpp
				03copyassign.cpp
	
【2】总结
		类中特殊的成员函数（4个）
		1. 构造函数
		2. 析构函数 
		3. 拷贝构造函数
		4. 拷贝赋值函数

【3】this指针
1. 定义：类的构造函数和成员函数中，形参中都隐藏了一个类 类型的指针
		指针的名字是this
		
		eg：
		class A{
			public:
			A(void){}
			// A(A* this){}
			void func(void){}
			// void func(A* this){}
		};
2. 在构造函数或者成员函数中，访问类中的成员变量，都是通过this指针实现的
	eg：
	class A{
		public:
		A(int data){}
		// A(A* this){
			m_data = data;
			// this->m_data = data;
		}
		void func(void){}
		// void func(A* this){
			//cout << m_data << endl;
			cout << this->m_data << endl;
		}
		
		private:
			int m_data;
	};

3. 对于成员函数，this指针指向的是调用该函数的实例化的对象。

	A a;
	a.func();
	
	参考案例：04this.cpp 
		

4. 必须显示使用this指针的场景
	1》区分作用域
	eg:
	class A{
		A(int m_data){
			this->m_data = m_data;
		}
		private:
		int m_data;
	}
	
	2》成员函数返回自引用
		A& func(void)
		{
			return *this;
		}
	
	3》在类的内部销毁对象时，必须显示使用this指针
	
		eg：		
		class A{
			A(void){}
			
			void destroy(void){
				delete this;
			}
		
		};		
		A *a = new A;
		//delete a;   //类的外部销毁对象
		
		a->destroy();  // 在类的内部销毁对象 
		
【4】常函数
	普通函数：
		返回类型  函数名(形参表){函数体}
		
1. 定义：在一个成员函数的形参表和函数体之间加一个const关键字，
		这样的行数称之为常函数。
		
	语法：
		返回类型  函数名(形参表)const{函数体}
		
2. 常函数中的const是用来修饰this指针的，再函数体中，
	不能修改this指针指向的成员变量
	
	eg：
	class A{
		public:
		void func(void)const{}
		// void func(const A * this){}  // 编译器编译成这样
		
		private:
			int m_data;
	};
	
	
	const char* str = "nozuonodei";
	char const *str = "nozuonodei";
	char* const str = "nozuonodei";
	
	const int data = 10;
	
3. 我就想在常函数中修改类中的成员，
	在类的成员变量前边添加一个关键字mutable，
	
	参考案例：05const.cpp 
	
4. 非 常对象可以调用常函数和普通成员函数
	常对象只可以调用常函数，不可以调用普通成员函数。
	
	非 常对象：   A  a;
	常对象 ： const A a;
	
	注意：常对象也可以是指针或者引用
	
	参考案例：06const.cpp 
	
5. 函数名和形参相同的函数，他的常版本和非常版本可以构成重载关系。
	常对象调用常版本
	非 常对象调用非 常版本
	
	参考案例：07const.cpp 
	
	
【5】静态成员  使用static修饰的成员
1. 静态成员变量
	语法格式：
	class  类名{
		
		static 变量类型  变量名;  // 声明静态成员变量
	};
	变量类型  类名::变量名 = 初始值;  // 静态成员变量的定义和初始化
	
	
	1》静态成员的初始化必须在类的外部完成定义和，
		在类地构造函数中不可以对静态成员初始化 
		
	2》非静态成员变量属于对象，静态成员变量不属于对象，
	
	3》静态成员放在全局区，跟全局变量类似都放在全局区
	
	4》对静态成员的访问，可以通过通类名加作用域限定符的方式进行访问，
		或者使用对象名加静态成员变量的方式进行访问。
		
		对象名.静态成员变量 
		类名::静态成员变量
	5》静态成员变量也受访问控制符的限制，
		如果是私有的静态成员，只能在类的内部进行访问。
		
		但是静态成员的定义和初始化依然在类的外部去定义和初始化。
		变量类型  类名::变量名 = 初始值;
		
	参考案例：08static.cpp
				09static.cpp

2. 静态成员函数
	class 类名{
		static 返回类型  函数名(形参表){函数体}
	};
	
	1. 对于静态成员函数的访问，使用-->类名::函数名(形参表);
	2. 静态成员函数不包含隐藏的this指针,不能是常函数
	3. 静态成员函数不可以访问普通的成员变量，只可以访问静态成员变量。
		因为静态成员函数没有this指针，所以不能指向类中的普通成员变量，
		所以不能访问普通成员变量。因为静态成员变量属于全局变量，
		所以静态成员函数可以访问静态成员变量。
		
	4. 普通的成员函数既可以访问静态成员变量，也可以访问普通的成员变量。
	
		普通成员函数访问普通的成员变量，通过this指针，
		而访问静态的成员变量，直接访问，因为静态成员变量不属于类，
		属于全局变量，所以不能通过this指针去访问，可以直接访问
	
	参考案例：10staticfunc.cpp
	
【6】运算符重载 ---》扩展
	定义：重新实现一个运算符
	+：  只能计算普通数据类型的加法运算吧
	
	对于特殊类型的变量“+”运算符，不能进行运算吧。
	
	可以通过运算符重载的方式对“+”运算符重新实现，
	让其可以对特殊类型的变量进行加法运算。
	
	复数：实部+虚部i
	
	class Complex{
		Complex(int r, int i):m_r(r),m_i(i){}
		private:
			int m_r; // 实部
			int m_i; // 虚部
	};
	
	Complex c1(1,3);   //  1 + 3i
	Complex c2(2,4);   //  2 + 4i	
	
	Complex c3 = c1 + c2;
	 参考案例：11complex.cpp
	
	
	
	
	
	
	
	
	
	
	
	













