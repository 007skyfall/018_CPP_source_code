回顾：
1. 函数
	1》缺省参数
		默认有实参，优先使用实参
		缺省参数，遵循靠右原则
	2》哑元参数
		形参只有数据类型，没有名字
		
	3》内联函数
		inline
		
2. 动态内存的分配
	new/delete
	new[]/delete[]
	
	1. 分配的空间在堆区
	2. new/delete是一个运算符
	3. 分配空间可以同时进行初始化
	
3. 面向对象
	1》什么是对象？
	2》如何符合描述对象？
		属性，行为
		
	3》面向对象编程的思想
		考虑共性，统一性
		
	4》什么是类？
		类是表示对象的新的数据类型

4. 类 
	类的一般形式：
	class 类名{
		构造函数
		类名(形参表){...}
		
		析构函数
		~类名(void){...}
		
		普通的成员函数;
		
		成员变量;
	
	
	};
	
	2. 类的访问控制属性
		public:共有的
		private:私有的
		protected:保护的

5. 构造函数 
	1》class 类名{
			类名(形参表){...}
		}
		1. 构造函数没有返回值
		2. 构造函数名和类名一致
		3. 构造函数作用，对类中的成员进行初始化
		4. 当你实例化一个对象的时候，构造函数被自动调用
	
	2》构造函数可以有重载的版本 
		构造的形参表不同，实现构造函数的重载
		
		根据实例化对象时，传递的构造的实参的不同，
		调用对应的构造函数。
		
	3》如果类中没有任何构造函数，编译器默认会提供一个
		缺省的无惨构造函数。
		
		类名(void){}

	4》构造函数只在实例化对象的时候被调用一次。

6. 多文件的编译
	student.h文件
	class student{
	public:
		student(const string name);
		void who(void);
	private:
		string m_name;
	};
	
	student.cpp文件
	
	student::student(const string name)
	{
		m_name = name;
	}
	
	void student::who(void)
	{
		cout << m_name << endl;
	}
	
##################################################
【1】构造函数中的初始化表
1. 初始化表定义
	eg：
	class A {
		public:
		// 先构造在初始化
		A(int data)
		{
			m_data = data;
		}
		private:
			int m_data;
	};
	
	初始化表：通过初始化表对类中的成员进行初始化的
	基本语法：
	class 类名{
		public:
		// 构造的同时进行初始化
		A(形参表):类中成员1(形参名),类中成员2(形参名),...
		{
		}
	};
	
	eg：
 	class A{
		public:
		A(void):m_age(25),m_no(10086){}
		A(int data):m_age(data),m_no(data){}
		A(int age, int no):m_age(age),m_no(no){}
		
		private:
		int m_age;
		int m_no;
	};
	测试代码：01initlist.cpp 
	
	练习：
	class A{
		public:
			A(int data):m_data(new int(data))
			{
				// m_data = new int(data);
			}
		private:
			int *m_data;
	}
	A a(50);
	
	参考案例：02initlist.cpp
	
2. 在实际开发中必须使用初始化表的地方
	1》如果类中包含"const"修饰的变量，或者”引用&“型变量，
		必须使用初始化表的方式，对成员进行初始化
		
	参考案例：03initlist.cpp
	
	2》如果类中有类类型的成员变量，
	必须使用初始化表的方式对成员子对象的构造函数传递实参。

	class A{
		public:
		A(int data):m_data(data){}
		int m_data;
	};
	
	class B{
		public:
		B(int data):m_a(data){}
		A m_a;
	};

【2】析构函数
1. 析构函数的语法格式
	class 类名{
		public:
		// 构造函数
		类名(形参表):(初始化表){}
		// 析构函数 
		~类名(void){}
	};
	1> 析构函数是类中的特殊的成员函数，名字:“~类名(void)”
	2> 析构函数没有返回类型，形式参数为void，
	3> 析构函数没有重载版本，每个类中只有一个析构函数
	4> 析构函数使用来释放构造函数申请的资源
	5> 构造函数在实例化一个对象的时候被调用，
	   析构函数在销毁对象的时候被调用
	参考案例： 05dest.cpp 
	
2. 析构函数的调用时机
	对象销毁的时候，自动的调用析构函数
	
	1》在栈区的对象，在这个对象的作用域的“}”,自动调用析构函数
		"}"含义：运算结束符,
		需要考虑实例化对象的作用域，遇到作用域的“}”，才可以
	2》在堆区的对象，调用delete销毁对象的时候，自动调用析构函数
		
	
	eg：
	class A{
		public:
		A(void){
			cout << "我是构造函数" << endl;
		}
		~A(void){
			cout << "我是析构函数" << endl;
		}
	};
	
	int main()
	{
		A a1;  // 栈区
		
		A *a2 = new A;  // 堆区
		delete a2;
		a2 = NULL;
		return 0;
	}
	
	参考案例：06dest.cpp 
	
3. 如果类中没有显示的定义一个析构函数，编译器默认会提供一个
	缺省的析构函数   ~类名(void){}

	1. 缺省的析构函数，什么都不做
	2. 如果显示的定义了一个析构函数，编译器不在提供缺省的析构函数。
	3. 如果类中有类 类型的成员变量，调用对应类中的析构函数
		完成析构。
		
	eg：
		class A{
			public:
			A(void){
				cout << "A::我是构造函数" << endl;
			}
			~A(void){
				cout << "A::我是析构函数" << endl;
			}
		};
		
		class B{
			public:
			B(void){
				cout << "B::我是构造函数" << endl;
			}
			~B(void){
				cout << "B::我是析构函数" << endl;
			}
			A m_a;
		};
		
		int main()
		{
			B b;
			
			return 0;
		}

【3】拷贝构造函数
	eg：
	class A{
		A(int data):m_data(data){}
		public:
		int m_data;
	};
	
	
	A a(100);
	
	A a2(a);     // 调用拷贝构造函数
	A a3 = a;   // 和上边是等价的  // 调用拷贝构造函数

1. 定义
	实例化一个对象，使用相同的类实例化的对象，对这个对象
	进行初始化，此时会调用类中的特殊成员函数拷贝构造函数。
	
	管这个赋值的过程叫做拷贝构造
	
	语法：
	类名(const 类名& that){
		类中的成员变量 = that.类中的成员变量;
	}
	
	参考案例：08copycons.cpp
	
2. 缺省的拷贝构造函数
	1》如果类中没有写拷贝构造函数，编译器默认会提供一个缺省的拷贝构造函数
		类名(const 类名& that):类的成员1(that.类的成员1),
								类的成员1(that.类的成员1),...{}
								
	2》拷贝构造函数是对类中的成员一对一进行拷贝的。
		参考案例：09copycons.cpp
	
	
	3》如果类中已经包含了一个拷贝构造函数，编译器不在提供缺省的拷贝构造函数
		参考案例：08copycons.cpp 
	4》对于类中包含类 类型的成员变量，会调用对应类中的拷贝构造函数
	
	参考案例：10copycons.cpp
	
3. 浅拷贝和深拷贝
	如果是编译器提供的缺省的拷贝构造函数，他就是一个浅拷贝
	
	深拷贝构造函数，需要自己手动完成
	
	总结：如果一个类中包含指针类型的成员变量，如果使用缺省的
	拷贝构造函数，拷贝的是指针的本身，而没有赋值指针指向的
	地址空间的值，这就是浅拷贝。
	
	浅拷贝当你去释放资源是，就是报“double free”异常。
	
	所以如果类中包含指针类型的成员变量是，需要使用深拷贝，
	深拷贝的事项需要我们显示的定义拷贝构造函数，重新分配地址空间，
	并且完成指针指向地址空间中的内容的拷贝。

	参考案例：11copycons.cpp
	
	案例：重构String类  12copycons.cpp
		
		练习：
		使用初始化表的方式，完成成员变量的初始化
		
		
		
		
		
		
		
		
		



	
	
	
	
	