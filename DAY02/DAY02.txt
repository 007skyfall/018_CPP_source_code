回顾：
1、名字空间的使用
	1>namespace ns1{
		成员;	
	}
	名字空间成员：全局，函数，自定义的类型，嵌套名字空间

	2>访问：名字空间名::成员
	
	3>名字空间指令
	using namespace 名字空间名;
	
	using namespace std;
	4>名字空间的声明
	using 名字空间名::成员名
	5>嵌套名字空间
	
	6>无名名字空间
2、数据类型
	自定义数据类型：
	1. 声明自定义类型的数据变量时，可以省略关键字
	2. struct结构体中可以包含成员函数
	bool类型
	
	string类 类型的
	
	
3. 	函数重载
	函数重载的3个条件：
		1. 相同作用域
		2. 相同的函数名
		3. 参数不同，参数的个数，参数的类型
		
	函数重载的原理：
		前缀 + 函数名 + 形参数据类型的首字母
		
	函数匹配：
	完全匹配 > 常量匹配 > 升级匹配 > 降级匹配 > 省略号匹配

4. 引用
	语法：数据类型&  引用名字 = 引用的目标
	
	1. 引用声明的时候，必须指定引用的目标
	2. 引用的类型和引用目标的类型必须一致
	3. 引用的目的，可以提高代码的执行效率
	
###################################################
【1】函数
	1. 缺省参数
		1>可以再函数的形参，在函数定义的时候，指定一个初始值。
		函数调用时，如果都指定了实参，优先使用实参的值。
		如果不指定实参，就是使用缺省的值
	
		eg：void func(int x, int y = 100)
		
		func(100,200);
		func(100),
		
		2> 靠右原则，形参表中对部分指定缺省值，应该都放到
		形参表的最右边
		
		eg： void func(int x, int y = 100, int z) // 编译器报错
		
		如果形参没有指定缺省值，必须传递一个实参
		
		3>函数声明和函数定义
			缺省值应该写到函数的声明的位置，
			因为函数调用时，只能看到函数声明，看不到函数定义的位置。

	2. 哑元参数
		定义：形参只指定形参的类型，没有指定形参的名字
		eg：void func(int x, int)  
		
		算法函数：
		func(int x, int y){}
		
		算法升级：
		func(int x){}
		
		为了兼容老的代码，会提供一个哑元参数。

	2. 内联函数  inline
		1. 使用inline修饰的函数，表示这个函数是一个内联函数。
		编译器在编译的时候，直接使用函数去替换函数调用的位置，
		节省函数调用开销，消耗内存。
		
		以空间换时间，
		
		内联函数的使用场合，适用于函数调用比较频繁的场合，
		内联函数代码量小。
		
		语法：inline 返回类型 函数名(形参){...}
		
		注意：
		内联修饰是一种建议，而不是强制要求，一个函数是否使用内联
		进行优化，主要取决于编译器。
		
		有些函数即使使用了inline修饰，编译也不会编译成内联函数。
		有些函数不加inline，编译器也会把他编译成内联函数。
		
		内联函数的展开在编译阶段执行。
		
【2】C++中的动态内存分配	
1. C语言中动态内存的分配
	malloc();
	内存的管理：
	栈区：局部变量和形参，系统自动分配，自动回收
	堆区：malloc()  手动分配，手动释放(free())
	数据段：初始化的全局变量，使用static修饰的静态变量 
				系统自动分配，自动回收
	BSS:未初始化的全局变量，未初始化的静态变量
	code：代码  Read-Only
	free();
	
2. C++中使用new/delete运算符实现动态内存的分配和释放
	new/new[]:分配内存
	delete/delete[]:释放内存
	
	eg1：
	int *pi = new int;  // 表示分配4个字节的空间
	*pi = 10;
	delete pi;     // 释放pi指向的地址空间
	
	int *pi2 = new int;  // 跟pi指向的是同一块地址空间
	
	*pi = 20;  编译不会报错，会变成野指针，非常危险
	
	pi = NULL;  释放之后，让指针指向NULL
	
	eg2：
	int *pi = new int[10] // 表示分配sizeof(int)*10这么大的地址空间
	初始化：
	for(int i = 0; i < 10;i++) {
		pi[i] = i;
	}
	
	访问：
	for(int i = 0; i < 10;i++) {
		cout << pi[i] << ' ';
	}
	cout << endl;
	
	delete[] pi; // 释放 
	pi = NULL;
	
	注意：连续内存的释放，一定不要忘记加[],
	他只释放一个数据类型(在new int[])空间,内存泄露。
	
	测试代码：
	
	malloc分配的内存空间的值并不一定是0，如果重新分配的可能是0，
	需要使用memset清零。
	
	malloc只能malloc一块空间，同时进行初始化。
	
	new在分配空间的同时可以进行初始化。
	
	eg：int *pi = new int(100);
		//*pi = 100;  new的时候已经制定初始值，不需要在初始化
		delete pi;
		pi = NULL;
		
		
		// c++98标准不支持， 使用C++11之后的标准
		int *pa = new int[10]{1,2,3,4,5,6,7,8,9,10};
		delete[] pa;
		pa = NULL;
		
		g++  ***.cpp -std = c++0x
	
	
	面试题：
	总结malloc/free和new/delete区别？
	
/******************************************
		面向对象编程
*******************************************/
【1】什么是对象？
	世间万物都可以当初一个对象去对象，每个事物都是一个对象。
【2】如何描述和表达这个对象
	通过对象的属性(名词，量词，形容词)和行为(动词)表达这个对象。
	
	eg：人类(human)
	属性：性别，年龄，身高，体重....
	行为：吃喝拉撒睡
	
	冰箱：
	属性：品牌，容量，功耗。。。
	行为：冷冻，冷藏，保鲜
【3】面向程序的设计
	对于自然界中对象观察引入到编程实践中的一种概念和方法，
	这种称为数据的抽象。
	在抽象这个对象时，把细节的东西剥离出去，只考虑一般性，
	有规律性，统一性的东西。
	
【4】什么是类
	类是将对象的共性提取出来，封装成一个新的数据类型，
	这就是类 类型。
	类是对对象的属性和行为的抽象描述，这个对象是类的实例化
	
	eg：
	    现实世界                类               虚拟世界
	具体对象--数据抽象--》属性/行为--实例化---》具体对象
									   |
							   声明类 类型变量
							   
	eg：冰箱
	struct bingxiang{
		string name;
		int  volume;
		int power;
		
		void lengcang(){...}
		void lenddong(){...}
		void baoxian(){...}
	};
	
	//之前：定义一个结构体类型的变量
	//之后：实例化一个结构体类型的对象
	struct bingxiang  bx1;
【5】面向对象程序设计的三大特征
		1》封装 
			函数封装
			类封装
		2》继承
		3》多态
	
【6】类的一般形式
	class 类名{
	成员访问控制属性：
	构造函数：  module_init()  分配资源，初始化成员函数
	类名(形参表){....}
	析构函数：  module_exit()  释放资源
	~类名(void){...}
	成员函数：
	返回值类型   函数名(形参表){...}
	成员变量：
	数据类型  变量名;
	};
		
		
【7】访问控制属性
	public：公有的
		在类的内部和类的外部都可以直接访问
	private：私有的
		在类的内部可以访问，类的外部不可以访问
	protected：保护的
		在类的内部可以访问，类的外部不可以访问，
		子类中可以访问基类中的保护成员
		
	class A{
	public:
		***;公有的
		***;公有的 
	private：
		***;私有的
		***;私有的 
	protected:
		***;保护的
	public:
		***;公有的
	};
	
	面试题：struct类型成员，成员默认都是public
		class类类型，不加访问控制属性，成员默认为private
		结构体中没有构造函数和析构函数。
		
测试案例：

【8】构造函数
	class A{
		类名(形参表)
		{
			函数体
		}
	};
	
	1. 构造函数的函数名和类名相同，
	2. 构造函数没有返回类型
	3. 构造函数在实例化一个对象的时候，会自动的调动，
		A a;
	4. 构造函数主要是对类中的成员进行初始化
	5. 构造函数在实例化对象的时候，只调用1次，一定会被调用
	
	重点掌握：构造函数的语法

	
【9】对象创建和销毁
	1. 在栈区创建一个对象
		类名 对象名(构造的实参表);
		类名 对象名 = 构造函数名(构造的实参表);
	2. 在栈区创建连续的多个对象
		类名 对象名[元素个数] = 
			{构造函数名(构造实参表),构造函数名(构造实参表),...}
			
		构造函数名 == 类名
	
	3. 在堆区创建/销毁一个对象
		创建：类名 *对象指针 = new 类名(构造实参表);
		销毁：delete 对象指针;
		
	4. 在堆区创建/销毁连续的多个对象
		创建：类名 *对象指针 = new 类名[元素的个数]{
			构造函数名(构造实参表),构造函数名(构造实参表),...}
		销毁：delete[] 对象指针;

【10】多文件的编译
	1. 类的声明在.h文件中实现
	2. 类中的成员函数在.cpp中实现
		需要使用类的作用域限定符
		
		类名::类中的成员

【11】构造函数
	1. 构造函数可以实现重载
	构造函数可以通过参数的不同，构成重载的构造函数，
	创建对象时，根据传递参数的不同，自动调用对应的构造函数，
	表示对象的不同的创建方式
	
	后边学习QT，QT类，构造函数重载
	
	eg：
	class Teacher{
		
		Teacher(const string& name, 
				const string& sex,
				const string& teach)
		{...}
		Teacher(const string& name, 
				const string& sex){...}
		Teacher(const string& name){...}
		
		private:
		string m_name;
		string m_sex;
		string m_teach;
	};
	
	2. 缺省构造函数(默认构造函数)
		2.1 如果一个类中没有定义构造函数，编译器会给你提供
		一个缺省的无惨构造函数。
		eg：
		class A{
			public:
				// A(void){}  缺省的构造函数
			private:
			int m_data;
		}
		
		2.2 缺省的构造函数不对成员进行初始化
		
		2.3 类中包含类 类型的成员变量，类 类型的成员，
			会调用自己类中的构造函数进行初始化。
			
			案例14；
			
		2.4 如果一个类中定义了构造函数，无论构造函数是否有参数，
		编译器就不在提供缺省的构造函数。
		
		
	
	
	
		
		







